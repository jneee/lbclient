## 1. 方案构思
![](/pic/req_process.png)

1. 设置线程数和ip数相同；
2. 请求会消耗token，请求完会生产token；
3. token内容是当前空闲的IP；
4. **token数等于IP数，保证大部分时间点每个后端处理的请求数相同**；
5. 一个线程动态获取IP，并更新req_toekn；
6. **token_queue ip数量也是backend的负载均衡权重**；
7. **多线程+token方式是【“后端处理快慢不一”的条件下实现负载均衡】的最佳调度算法**

## 2. 验证情况
![](/pic/run.png)

经验证满足了如下4点要求：
1. 发现域名对应的IP地址；
2. 请求应该均衡分布到不同服务器；
3. 客户端请求应该在无客户感知的前提下重试；  
    满足要求：判断 `总次数 - fail > 100` 才停止
4. 请求转发应尽量高效；  
    1. 相同线程下，实现了请求结束最快；
    2. 代码中，**增加token_queue中的token数量即改变线程数，可以缩短总请求时间**

同时考虑到了如下假设：
1. 域名背后的IP地址可能发生变动；  
  有个线程每2s获取一次ip地址，并更新 token_queue
2. 每个虚拟IP地址所在地理位置或处理能力不同，因此针对同一请求的处理时间不尽相同；  
  采用多线程+token方式调度，**同一时刻每个后端处理的请求数相同**，结束时所有线程能几乎同时完成；
3. 虚拟IP地址可能会因为系统维护等原因不可达；  
  捕获异常并且计为 `fail`
4. 如果返回码处于[200-500]之间，可视为成功，如果出现超时或500+的错误则视为失败  
  判断返回码并且将非[200-500]计为 `fail`
